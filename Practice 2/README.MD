# ЗАВДАННЯ 1:

## Умова:

Напишіть програму для визначення моменту, коли time_t закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та 64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

## Код задачі:
```c
#include <stdio.h>
#include <time. h>
#include <limits.h>

int main() {
    time_t max_time = (time_t)~((time_t)1 << (sizeof (time_t) * 8 - 1));
    printf ("Max time_t value: %ld\n", (long)max_time);
    printf ("Date and time: %s", ctime(&max_time));

    time_t overf low_time = max_time + 1;
    printf ("After overf low: %s", ctime(&overflow_time) );

    return 0;
}
```

## Як працює програма:

Програма визначає максимальне значення типу time_t, що залежить від розрядності архітектури (32-біт або 64-біт). На 32-бітній архітектурі значення переповниться після 19 січня 2038 року (проблема 2038 року). На 64-бітній архітектурі обмеження значно більше, і значення time_t покриває мільярди років. При переповненні time_t результати роботи функцій, таких як ctime, можуть стати некоректними.

## Результат роботи:

![](task1.png)


# ЗАВДАННЯ 2:

## Умова:

Розгляньте сегменти у виконуваному файлі.

1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для виконуваного файлу, щоб отримати його загальний розмір, і запустіть size, щоб отримати розміри сегментів всередині нього.
2. Додайте оголошення глобального масиву із 1000 int, перекомпілюйте й повторіть вимірювання. Зверніть увагу на відмінності.
3. Тепер додайте початкове значення в оголошення масиву (пам’ятайте, що C не змушує вас вказувати значення для кожного елемента масиву в ініціалізаторі). Це перемістить масив із сегмента BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на різницю.
4. Тепер додайте оголошення великого масиву в локальну функцію. Оголосіть другий великий локальний масив з ініціалізатором. Повторіть вимірювання. Дані розташовуються всередині функцій, залишаючись у виконуваному файлі? Яка різниця, якщо масив ініціалізований чи ні?
5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви компілюєте для налагодження? Для максимальної оптимізації?

Проаналізуйте результати, щоб переконатися, що:
● сегмент даних зберігається у виконуваному файлі;
● сегмент BSS не зберігається у виконуваному файлі (за винятком примітки щодо його вимог до розміру часу виконання);
● текстовий сегмент більшою мірою піддається перевіркам оптимізації;
● на розмір файлу a.out впливає компіляція для налагодження, але не сегменти.

## Код задачі:
```c
#include <stdio.h>

int main() {
    printf ("Hello world!\n");
    return 0:
}
```

## Як працює програма:

Це проста програма, яка демонструє розміри базового виконуваного файлу. Виконуваний файл містить тільки текстовий сегмент із кодом програми.

## Результат роботи:

![](task2_1.png)

## Код задачі:
```c
#include <stdio.h>

int arr[1000];

int main() {
    printf ("Hello world!\n");
    return 0:
}
```

## Як працює програма:

Глобальний масив додається до сегмента BSS, який не зберігається у виконуваному файлі, але резервується під час виконання. Розмір виконуваного файлу незначно змінюється, однак обсяг пам’яті, необхідний для виконання програми, збільшується.

## Результат роботи:

![](task2_2.png)

## Код задачі:
```c
#include <stdio.h>

int arr[1000] = {1};

int main() {
    printf ("Hello world!\n");
    return 0:
}
```

## Як працює програма:

Глобальний масив із початковим значенням переміщається з сегмента BSS до сегмента DATA. Це впливає на розмір виконуваного файлу, оскільки сегмент DATA зберігається у ньому.

## Результат роботи:

![](task2_3.png)

## Код задачі:
```c
#include <stdio.h>
void func() {
    int arr1[1000];
    int arr2[1000] = {1};
}
  
int main() {
    printf ("Hello world!\n");
    return 0:
}
```

## Як працює програма:

Локальні масиви створюються в стеку під час виконання програми. Масив без ініціалізації (arr1) розміщується в стеку, а масив із ініціалізацією (arr2) додає додаткові дані до текстового сегмента. Виконуваний файл змінюється лише через наявність ініціалізованого масиву.

## Результат роботи:

![](task2_4.png)

## Код задачі:
```c
#include <stdio.h>
void func() {
    int arr1[1000];
    int arr2[1000] = {1};
}
  
int main() {
    printf ("Hello world!\n");
    return 0:
}
```

## Як працює програма:

При компіляції з налагодженням файл містить додаткову інформацію для дебагу, що збільшує його розмір. Максимальна оптимізація зменшує розмір текстового сегмента, але не впливає на сегменти DATA і BSS. Масиви в стеку залишаються лише під час виконання програми, не змінюючи розміри виконуваного файлу.

## Результат роботи:

![](task2_5_1.png)

![](task2_5_2.png)
