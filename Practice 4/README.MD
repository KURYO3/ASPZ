# ЗАВДАННЯ 1:

## Умова:

Скільки пам’яті може виділити `malloc(3)` за один виклик? Параметр `malloc(3)` є цілим числом типу даних `size_t`, тому логічно максимальне число, яке можна передати як параметр `malloc(3)`, — це максимальне значення size_t на платформі (`sizeof(size_t)`). У 64-бітній Linux `size_t` становить 8 байтів, тобто 8 * 8 = 64 біти. Відповідно, максимальний обсяг пам’яті, який може бути виділений за один виклик `malloc(3)`, дорівнює 2^64. Спробуйте запустити код на x86_64 та x86. Чому теоретично максимальний обсяг складає 8 ексабайт, а не 16?

## Пояснення:

Теоретично максимальний обсяг пам’яті, який можна виділити за один виклик `malloc(3)`, обмежений типом `size_t`, який використовується для визначення розміру в байтах. На 64-бітових платформах `size_t` займає 8 байтів (64 біти), що дозволяє представляти числа до 2^64 - 1. Це означає, що максимальне значення, яке можна передати `malloc(3)`, дорівнює 2^64 - 1 байт, що еквівалентно приблизно 18446744073709551615 байт або 8 ексабайт.

Однак на практиці цей теоретичний максимум не може бути досягнутий через низку інших обмежень. Операційні системи зазвичай накладають свої власні ліміти на кількість пам’яті, яку може виділити один процес. Ці обмеження можуть бути обумовлені доступною віртуальною або фізичною пам’яттю, а також політиками безпеки системи. Тому, навіть якщо `malloc(3)` теоретично може запитати 8 ексабайт пам’яті, практична реалізація часто обмежується набагато меншою кількістю пам’яті.

Також важливо зазначити, що максимальний обсяг пам’яті становить саме 8 ексабайт, а не 16. Це пов’язано з тим, що 64 біти дозволяють закодувати 2^64 різних значень, а отже, максимальне число, яке можна представити – це 2^64 - 1, що і дорівнює приблизно 8 ексабайт. Для того щоб представити число, що перевищує цей ліміт, знадобився б додатковий біт, тобто використання 65 біт, що виходить за рамки стандартної 64-бітової архітектури.

Отже, хоча теоретично один виклик `malloc(3)` на 64-бітовій системі може виділити до 8 ексабайт пам’яті, на практиці реальні ліміти виділення пам’яті залежать від операційної системи, фізичних ресурсів і встановлених політик, через що максимальний обсяг пам’яті, який можна успішно виділити, значно менший за цей теоретичний максимум.


# ЗАВДАННЯ 2:

## Умова:

Що станеться, якщо передати malloc(3) від’ємний аргумент? Напишіть тестовий випадок, який обчислює кількість виділених байтів за формулою num = xa * xb. Що буде, якщо num оголошене як цілочисельна змінна зі знаком, а результат множення призведе до переповнення? Як себе поведе malloc(3)? Запустіть програму на x86_64 і x86.

## [Код до завдання](task2.c)

## Пояснення програми:

У цій програмі тестується поведінка `malloc()` при передачі від’ємного значення та при переповненні при множенні двох цілих чисел. Перший тест перевіряє, що станеться, якщо передати -1 як аргумент для `malloc()`. Як видно з результатів, `malloc()` не може виділити пам’ять і повертає `NULL`, що очікувано, оскільки параметр повинен бути беззнаковим числом. Далі програма тестує ситуацію, коли результат множення двох цілих чисел зі знаком викликає переповнення. Від’ємне значення `num` після множення `xa` та `xb` свідчить про переповнення, і спроба виділення такого обсягу пам’яті також завершується помилкою. Аналогічний тест проводиться з беззнаковими змінними, і в 32-бітній системі також виникає переповнення, яке спричиняє помилку при виділенні пам’яті.

## Результат роботи:

![](task2.png)


# ЗАВДАННЯ 3:

## Умова:

Що станеться, якщо використати malloc(0)? Напишіть тестовий випадок, у якому malloc(3) повертає NULL або вказівник, що не є NULL, і який можна передати у free(). Відкомпілюйте та запустіть через ltrace. Поясніть поведінку програми.

## [Код до завдання](task3.c)

## Пояснення програми:

Ця програма досліджує поведінку `malloc(0)`. Поведінка `malloc(0)` залежить від реалізації, він може повернути `NULL` або ненульовий вказівник, який можна передати `free()`. У результатах роботи програми видно, що `malloc(0)` повернув певний вказівник, який можна було звільнити за допомогою `free()`, що підтверджує можливу поведінку цього виклику.

## Результат роботи:

![](task3.png)


# ЗАВДАННЯ 4:

## Умова:

Чи є помилки у такому коді?
```c
void *ptr = NULL;
while (<some-condition-is-true>) {
    if (!ptr)
        ptr = malloc(n);
    [... <використання 'ptr'> ...]
    free(ptr);
}
```

Напишіть тестовий випадок, який продемонструє проблему та правильний варіант коду.

## Коди до задачі:

### [Початковий код](task4.c)

### [Приклад проблеми](task4e.c)

### [Правильний варіант коду](task4r.c)

## Пояснення програми:

Ця програма демонструє проблему використання вказівника після його звільнення. У початковому варіанті коду після `free()` вказівник `ptr` не оновлюється, тому в наступній ітерації він може залишатися невизначеним, що може спричинити використання звільненої пам’яті. У тестовому прикладі показано, як вказівник все ще містить старі дані після виклику `free()`, що є потенційною помилкою. Правильний варіант коду вирішує проблему, встановлюючи `ptr` у `NULL` після виклику `free()`, що унеможливлює повторне використання звільненої пам’яті.

## Результат роботи:

![](task4.png)


# ЗАВДАННЯ 5:

## Умова:

Що станеться, якщо realloc(3) не зможе виділити пам’ять? Напишіть тестовий випадок, що демонструє цей сценарій.

## [Код до завдання](task5.c)

## Пояснення програми:

Коли `realloc(3)` не може виділити пам’ять, вона повертає `NULL`, а початковий вказівник залишається дійсним і повинен бути звільнений вручну. У коді виділяється спочатку 1024 байти, що вдається зробити, після чого виконується `realloc(ptr, big_size)`, де `big_size` встановлений у 1 ТБ. Система не може виділити такий великий обсяг пам’яті, що призводить до помилки. У виводі програми спочатку вказано, що первинне виділення пам’яті пройшло успішно, проте після `realloc` система вичерпала простір підкачки (`swap_pager: out of swap space`), а ядро FreeBSD зупинило процес через неможливість звільнити пам’ять (`pid 1158 (task5) was killed: failed to reclaim memory`). Це означає, що операційна система намагалася зарезервувати запитану пам’ять, але, коли її виявилося недостатньо, процес було завершено, щоб запобігти загальному зависанню системи.

## Результат роботи:

![](task5.png)


# ЗАВДАННЯ 6:

## Умова:

Якщо realloc(3) викликати з NULL або розміром 0, що станеться? Напишіть тестовий випадок.

## [Код до завдання](task6.c)

## Пояснення програми:

Ця програма тестує два випадки використання `realloc`:

- Якщо `realloc(NULL, size)` викликається, він працює так само, як `malloc(size)`, тобто виділяє новий блок пам’яті.

- Якщо `realloc(ptr, 0)` викликається, зазвичай він або повертає `NULL`, або діє так само, як `free(ptr)`.

Перше повідомлення свідчить про те, що `realloc(NULL, 16)` виділив нову область пам’яті за адресою `0x3b60f9209000`, тобто працював аналогічно `malloc(16)`. Далі `ptr2` був успішно виділений через `malloc(32)`, отримавши адресу `0x3b60f9214000`. Останній рядок показує, що `realloc(ptr2, 0)` повернув нову адресу `0x3b60f9208008`. Це означає, що в реалізації `realloc` у FreeBSD функція не лише звільняє пам’ять, а й повертає певну службову адресу.

## Результат роботи:

![](task6.png)


# ЗАВДАННЯ 7:

## Умова:

Перепишіть наступний код, використовуючи reallocarray(3):
```c
struct sbar *ptr, *newptr;
ptr = calloc(1000, sizeof(struct sbar));
newptr = realloc(ptr, 500*sizeof(struct sbar));
```

Порівняйте результати виконання з використанням ltrace.

## [Код до завдання](task7.c)

## Пояснення програми:

Тут потрібно переписати код із використанням `reallocarray(3)`, який працює аналогічно `realloc`, але безпечно обчислює розмір виділеної пам’яті, запобігаючи переповненню. Спочатку `calloc(1000, sizeof(struct sbar))` успішно виділяє область пам’яті, про що свідчить повідомлення `calloc successful: ptr = 0x205518609000`. Потім виконується `reallocarray(ptr, 500, sizeof(struct sbar))`, який зменшує розмір області, і повертається новий вказівник `0x205518613000`. Вивід `ltrace` показує, що спочатку виконується `calloc(1000, 4)`, потім `reallocarray(0x204f49009000, 500, 4)`, і новий вказівник успішно змінюється. Це підтверджує, що `reallocarray` коректно переобчислює розмір і працює так само, як `realloc`, але із додатковою безпекою від переповнення.

## Результат роботи:

![](task7.png)


# ЗАВДАННЯ ПО ВАРІАНТАХ (7 ВАРІАНТ):

## Умова:

Напишіть програму, яка перевіряє ефективність cache locality для розподіленої пам’яті.

## [Код до завдання](task8.c)

## Пояснення програми:

Програма тестує ефективність доступу до пам’яті при построковому та постовпчиковому обході. В результатах виконання:

- Для `SIZE = 1024` час доступу по рядках та по стовпцях приблизно однаковий.

- Для `SIZE = 8192` построчний доступ займає ~1.3 секунди, тоді як постовпчиковий — понад 8 секунд.

Це відбувається через кешування пам’яті: процесор кешує дані по рядках, тому построчний доступ є значно ефективнішим. При проходженні по стовпцях доступ до пам’яті відбувається не послідовно, що призводить до частих кеш-промахів і значного сповільнення виконання.

## Результат роботи:

*`#def int SIZE 1024`*

![](task8(1024).png)

*`#def int SIZE 8192`*

![](task8(8192).png)
